"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "components_map_SharedMapComponent_tsx";
exports.ids = ["components_map_SharedMapComponent_tsx"];
exports.modules = {

/***/ "./components/map/SharedMapComponent.tsx":
/*!***********************************************!*\
  !*** ./components/map/SharedMapComponent.tsx ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-leaflet */ \"react-leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"axios\");\n/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! leaflet/dist/leaflet.css */ \"./node_modules/leaflet/dist/leaflet.css\");\n/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var leaflet_dist_images_marker_icon_2x_png__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! leaflet/dist/images/marker-icon-2x.png */ \"./node_modules/leaflet/dist/images/marker-icon-2x.png\");\n/* harmony import */ var leaflet_dist_images_marker_icon_png__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! leaflet/dist/images/marker-icon.png */ \"./node_modules/leaflet/dist/images/marker-icon.png\");\n/* harmony import */ var leaflet_dist_images_marker_shadow_png__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! leaflet/dist/images/marker-shadow.png */ \"./node_modules/leaflet/dist/images/marker-shadow.png\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([react_leaflet__WEBPACK_IMPORTED_MODULE_2__, axios__WEBPACK_IMPORTED_MODULE_4__]);\n([react_leaflet__WEBPACK_IMPORTED_MODULE_2__, axios__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n // Added Polygon\n\n // Import axios for API calls\n // Import Leaflet CSS\n// Fix for default marker icon issue with webpack/Next.js\n// (See: https://github.com/PaulLeCam/react-leaflet/issues/808)\n\n\n\n// Explicitly set the default icon paths\ndelete (leaflet__WEBPACK_IMPORTED_MODULE_3___default().Icon).Default.prototype._getIconUrl; // Type assertion needed\nleaflet__WEBPACK_IMPORTED_MODULE_3___default().Icon.Default.mergeOptions({\n    iconRetinaUrl: leaflet_dist_images_marker_icon_2x_png__WEBPACK_IMPORTED_MODULE_6__[\"default\"].src,\n    iconUrl: leaflet_dist_images_marker_icon_png__WEBPACK_IMPORTED_MODULE_7__[\"default\"].src,\n    shadowUrl: leaflet_dist_images_marker_shadow_png__WEBPACK_IMPORTED_MODULE_8__[\"default\"].src\n});\n// Function to get a specific icon based on the source\n// TODO: Define custom icons for different sources (Kappa, Djinn, Ghost, etc.)\nfunction getIconForSource(source) {\n    // Example: Return different icons based on source\n    // if (source === 'djinn') return djinnIcon;\n    // if (source === 'kappa') return kappaIcon;\n    // For now, return the default icon for all sources\n    // Create a new Icon instance with explicit options to satisfy TypeScript\n    return new (leaflet__WEBPACK_IMPORTED_MODULE_3___default().Icon)({\n        iconUrl: leaflet_dist_images_marker_icon_png__WEBPACK_IMPORTED_MODULE_7__[\"default\"].src,\n        iconRetinaUrl: leaflet_dist_images_marker_icon_2x_png__WEBPACK_IMPORTED_MODULE_6__[\"default\"].src,\n        shadowUrl: leaflet_dist_images_marker_shadow_png__WEBPACK_IMPORTED_MODULE_8__[\"default\"].src,\n        iconSize: [\n            25,\n            41\n        ],\n        iconAnchor: [\n            12,\n            41\n        ],\n        popupAnchor: [\n            1,\n            -34\n        ],\n        shadowSize: [\n            41,\n            41\n        ] // Default shadow size\n    });\n}\n// Example initial center and zoom\nconst defaultCenter = [\n    51.505,\n    -0.09\n]; // London coordinates\nconst defaultZoom = 13;\nconst SharedMapComponent = ()=>{\n    const [markers, setMarkers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [footprints, setFootprints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]); // State for footprints\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // TODO: Implement data fetching logic\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const fetchMapData = async ()=>{\n            setIsLoading(true);\n            setError(null);\n            setMarkers([]); // Clear previous markers\n            setFootprints([]); // Clear previous footprints\n            try {\n                // Fetch data from the backend API endpoint\n                // Assuming Next.js proxy routes /api/* to the backend (e.g., localhost:8000)\n                const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"/api/mapdata\"); // Use relative path for proxy\n                // Process Markers\n                if (response.data?.markers) {\n                    const fetchedMarkers = response.data.markers.map((m)=>({\n                            id: m.id,\n                            position: m.position,\n                            popupContent: m.popupContent,\n                            source: m.source\n                        }));\n                    setMarkers(fetchedMarkers);\n                    logger.debug(`Successfully fetched ${fetchedMarkers.length} markers.`);\n                } else {\n                    logger.warn(\"No marker data found in response.\");\n                    setMarkers([]); // Ensure markers are cleared if none are fetched\n                }\n                // Process Footprints\n                if (response.data?.footprints) {\n                    // Basic validation - could be more robust\n                    const fetchedFootprints = response.data.footprints.filter((f)=>f.type === \"Feature\" && f.geometry?.type === \"Polygon\" && Array.isArray(f.geometry.coordinates));\n                    setFootprints(fetchedFootprints);\n                    logger.debug(`Successfully fetched ${fetchedFootprints.length} footprints.`);\n                } else {\n                    logger.warn(\"No footprint data found in response.\");\n                    setFootprints([]); // Ensure footprints are cleared if none are fetched\n                }\n                if (!response.data?.markers && !response.data?.footprints) {\n                    throw new Error(\"Invalid or empty data format received from /api/mapdata\");\n                }\n            } catch (err) {\n                logger.error(\"Failed to fetch map data:\", err);\n                setError(err.message || \"Could not load map data.\");\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        fetchMapData();\n    }, []); // Empty dependency array means this runs once on mount\n    // Note: MapContainer needs a defined height/width via CSS to be visible.\n    // Ensure the parent container or a CSS rule provides this.\n    // Example: style={{ height: '500px', width: '100%' }}\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            height: \"600px\",\n            width: \"100%\",\n            border: \"1px solid #ccc\"\n        },\n        children:  false && /*#__PURE__*/ 0\n    }, void 0, false, {\n        fileName: \"F:\\\\Selkie\\\\Project\\\\frontend\\\\components\\\\map\\\\SharedMapComponent.tsx\",\n        lineNumber: 136,\n        columnNumber: 9\n    }, undefined);\n};\n// Add logger instance if needed\nconst logger = {\n    error: (...args)=>console.error(...args),\n    debug: (...args)=>console.log(...args),\n    warn: (...args)=>console.warn(...args)\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SharedMapComponent);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL21hcC9TaGFyZWRNYXBDb21wb25lbnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtRDtBQUM2QixDQUFDLGdCQUFnQjtBQUN6RTtBQUNFLENBQUMsNkJBQTZCO0FBQ3RCLENBQUMscUJBQXFCO0FBRXhELHlEQUF5RDtBQUN6RCwrREFBK0Q7QUFDSTtBQUNUO0FBQ0k7QUFFOUQsd0NBQXdDO0FBQ3hDLE9BQU8scURBQU8sQ0FBQ2MsT0FBTyxDQUFDQyxTQUFTLENBQVNDLFdBQVcsRUFBRSx3QkFBd0I7QUFDOUVSLG1EQUFNLENBQUNNLE9BQU8sQ0FBQ0csWUFBWSxDQUFDO0lBQ3hCUCxlQUFlQSxrRkFBaUI7SUFDaENDLFNBQVNBLCtFQUFXO0lBQ3BCQyxXQUFXQSxpRkFBYTtBQUM1QjtBQUNBLHNEQUFzRDtBQUN0RCw4RUFBOEU7QUFDOUUsU0FBU08saUJBQWlCQyxNQUFnQztJQUN0RCxrREFBa0Q7SUFDbEQsNENBQTRDO0lBQzVDLDRDQUE0QztJQUM1QyxtREFBbUQ7SUFDbkQseUVBQXlFO0lBQ3pFLE9BQU8sSUFBSVoscURBQU0sQ0FBQztRQUNkRyxTQUFTQSwrRUFBVztRQUNwQkQsZUFBZUEsa0ZBQWlCO1FBQ2hDRSxXQUFXQSxpRkFBYTtRQUN4QlMsVUFBVTtZQUFDO1lBQUk7U0FBRztRQUNsQkMsWUFBWTtZQUFDO1lBQUk7U0FBRztRQUNwQkMsYUFBYTtZQUFDO1lBQUcsQ0FBQztTQUFHO1FBQ3JCQyxZQUFZO1lBQUM7WUFBSTtTQUFHLENBQUMsc0JBQXNCO0lBQy9DO0FBQ0o7QUE2QkEsa0NBQWtDO0FBQ2xDLE1BQU1DLGdCQUFrQztJQUFDO0lBQVEsQ0FBQztDQUFLLEVBQUUscUJBQXFCO0FBQzlFLE1BQU1DLGNBQWM7QUFFcEIsTUFBTUMscUJBQStCO0lBQ2pDLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHNUIsK0NBQVFBLENBQWtCLEVBQUU7SUFDMUQsTUFBTSxDQUFDNkIsWUFBWUMsY0FBYyxHQUFHOUIsK0NBQVFBLENBQXFCLEVBQUUsR0FBRyx1QkFBdUI7SUFDN0YsTUFBTSxDQUFDK0IsV0FBV0MsYUFBYSxHQUFHaEMsK0NBQVFBLENBQVU7SUFDcEQsTUFBTSxDQUFDaUMsT0FBT0MsU0FBUyxHQUFHbEMsK0NBQVFBLENBQWdCO0lBRWxELHNDQUFzQztJQUN0Q0MsZ0RBQVNBLENBQUM7UUFDTixNQUFNa0MsZUFBZTtZQUNqQkgsYUFBYTtZQUNiRSxTQUFTO1lBQ1ROLFdBQVcsRUFBRSxHQUFHLHlCQUF5QjtZQUN6Q0UsY0FBYyxFQUFFLEdBQUcsNEJBQTRCO1lBQy9DLElBQUk7Z0JBQ0EsMkNBQTJDO2dCQUMzQyw2RUFBNkU7Z0JBQzdFLE1BQU1NLFdBQVcsTUFBTTVCLGlEQUFTLENBQUMsaUJBQWlCLDhCQUE4QjtnQkFFaEYsa0JBQWtCO2dCQUNsQixJQUFJNEIsU0FBU0UsSUFBSSxFQUFFWCxTQUFTO29CQUN4QixNQUFNWSxpQkFBa0NILFNBQVNFLElBQUksQ0FBQ1gsT0FBTyxDQUFDYSxHQUFHLENBQUMsQ0FBQ0MsSUFBWTs0QkFDM0VDLElBQUlELEVBQUVDLEVBQUU7NEJBQ1JDLFVBQVVGLEVBQUVFLFFBQVE7NEJBQ3BCQyxjQUFjSCxFQUFFRyxZQUFZOzRCQUM1QnpCLFFBQVFzQixFQUFFdEIsTUFBTTt3QkFDcEI7b0JBQ0FTLFdBQVdXO29CQUNYTSxPQUFPQyxLQUFLLENBQUMsQ0FBQyxxQkFBcUIsRUFBRVAsZUFBZVEsTUFBTSxDQUFDLFNBQVMsQ0FBQztnQkFDekUsT0FBTztvQkFDSEYsT0FBT0csSUFBSSxDQUFDO29CQUNacEIsV0FBVyxFQUFFLEdBQUcsaURBQWlEO2dCQUNyRTtnQkFFQSxxQkFBcUI7Z0JBQ3JCLElBQUlRLFNBQVNFLElBQUksRUFBRVQsWUFBWTtvQkFDM0IsMENBQTBDO29CQUMxQyxNQUFNb0Isb0JBQXdDYixTQUFTRSxJQUFJLENBQUNULFVBQVUsQ0FBQ3FCLE1BQU0sQ0FDekUsQ0FBQ0MsSUFBV0EsRUFBRUMsSUFBSSxLQUFLLGFBQWFELEVBQUVFLFFBQVEsRUFBRUQsU0FBUyxhQUFhRSxNQUFNQyxPQUFPLENBQUNKLEVBQUVFLFFBQVEsQ0FBQ0csV0FBVztvQkFFOUcxQixjQUFjbUI7b0JBQ2RKLE9BQU9DLEtBQUssQ0FBQyxDQUFDLHFCQUFxQixFQUFFRyxrQkFBa0JGLE1BQU0sQ0FBQyxZQUFZLENBQUM7Z0JBQy9FLE9BQU87b0JBQ0ZGLE9BQU9HLElBQUksQ0FBQztvQkFDWmxCLGNBQWMsRUFBRSxHQUFHLG9EQUFvRDtnQkFDNUU7Z0JBRUEsSUFBSSxDQUFDTSxTQUFTRSxJQUFJLEVBQUVYLFdBQVcsQ0FBQ1MsU0FBU0UsSUFBSSxFQUFFVCxZQUFZO29CQUN0RCxNQUFNLElBQUk0QixNQUFNO2dCQUNyQjtZQUVKLEVBQUUsT0FBT0MsS0FBVTtnQkFDZmIsT0FBT1osS0FBSyxDQUFDLDZCQUE2QnlCO2dCQUMxQ3hCLFNBQVN3QixJQUFJQyxPQUFPLElBQUk7WUFDNUIsU0FBVTtnQkFDTjNCLGFBQWE7WUFDakI7UUFDSjtRQUVBRztJQUNKLEdBQUcsRUFBRSxHQUFHLHVEQUF1RDtJQUUvRCx5RUFBeUU7SUFDekUsMkRBQTJEO0lBQzNELHNEQUFzRDtJQUV0RCxxQkFDSSw4REFBQ3lCO1FBQUlDLE9BQU87WUFBRUMsUUFBUTtZQUFTQyxPQUFPO1lBQVFDLFFBQVE7UUFBaUI7a0JBRWxFLE1BQWtCLGtCQUNmOzs7Ozs7QUEyQ2hCO0FBRUEsZ0NBQWdDO0FBQ2hDLE1BQU1uQixTQUFTO0lBQ1haLE9BQU8sQ0FBQyxHQUFHbUQsT0FBZ0JDLFFBQVFwRCxLQUFLLElBQUltRDtJQUM1Q3RDLE9BQU8sQ0FBQyxHQUFHc0MsT0FBZ0JDLFFBQVFDLEdBQUcsSUFBSUY7SUFDMUNwQyxNQUFNLENBQUMsR0FBR29DLE9BQWdCQyxRQUFRckMsSUFBSSxJQUFJb0M7QUFDOUM7QUFHQSxpRUFBZTFELGtCQUFrQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NlbGtpZS1mcm9udGVuZC8uL2NvbXBvbmVudHMvbWFwL1NoYXJlZE1hcENvbXBvbmVudC50c3g/YzhjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgTWFwQ29udGFpbmVyLCBUaWxlTGF5ZXIsIE1hcmtlciwgUG9wdXAsIFBvbHlnb24gfSBmcm9tICdyZWFjdC1sZWFmbGV0JzsgLy8gQWRkZWQgUG9seWdvblxyXG5pbXBvcnQgTCBmcm9tICdsZWFmbGV0JztcclxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJzsgLy8gSW1wb3J0IGF4aW9zIGZvciBBUEkgY2FsbHNcclxuaW1wb3J0ICdsZWFmbGV0L2Rpc3QvbGVhZmxldC5jc3MnOyAvLyBJbXBvcnQgTGVhZmxldCBDU1NcclxuXHJcbi8vIEZpeCBmb3IgZGVmYXVsdCBtYXJrZXIgaWNvbiBpc3N1ZSB3aXRoIHdlYnBhY2svTmV4dC5qc1xyXG4vLyAoU2VlOiBodHRwczovL2dpdGh1Yi5jb20vUGF1bExlQ2FtL3JlYWN0LWxlYWZsZXQvaXNzdWVzLzgwOClcclxuaW1wb3J0IGljb25SZXRpbmFVcmwgZnJvbSAnbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItaWNvbi0yeC5wbmcnO1xyXG5pbXBvcnQgaWNvblVybCBmcm9tICdsZWFmbGV0L2Rpc3QvaW1hZ2VzL21hcmtlci1pY29uLnBuZyc7XHJcbmltcG9ydCBzaGFkb3dVcmwgZnJvbSAnbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItc2hhZG93LnBuZyc7XHJcblxyXG4vLyBFeHBsaWNpdGx5IHNldCB0aGUgZGVmYXVsdCBpY29uIHBhdGhzXHJcbmRlbGV0ZSAoTC5JY29uLkRlZmF1bHQucHJvdG90eXBlIGFzIGFueSkuX2dldEljb25Vcmw7IC8vIFR5cGUgYXNzZXJ0aW9uIG5lZWRlZFxyXG5MLkljb24uRGVmYXVsdC5tZXJnZU9wdGlvbnMoe1xyXG4gICAgaWNvblJldGluYVVybDogaWNvblJldGluYVVybC5zcmMsXHJcbiAgICBpY29uVXJsOiBpY29uVXJsLnNyYyxcclxuICAgIHNoYWRvd1VybDogc2hhZG93VXJsLnNyYyxcclxufSk7XHJcbi8vIEZ1bmN0aW9uIHRvIGdldCBhIHNwZWNpZmljIGljb24gYmFzZWQgb24gdGhlIHNvdXJjZVxyXG4vLyBUT0RPOiBEZWZpbmUgY3VzdG9tIGljb25zIGZvciBkaWZmZXJlbnQgc291cmNlcyAoS2FwcGEsIERqaW5uLCBHaG9zdCwgZXRjLilcclxuZnVuY3Rpb24gZ2V0SWNvbkZvclNvdXJjZShzb3VyY2U/OiBNYXBNYXJrZXJEYXRhWydzb3VyY2UnXSk6IEwuSWNvbiB7XHJcbiAgICAvLyBFeGFtcGxlOiBSZXR1cm4gZGlmZmVyZW50IGljb25zIGJhc2VkIG9uIHNvdXJjZVxyXG4gICAgLy8gaWYgKHNvdXJjZSA9PT0gJ2RqaW5uJykgcmV0dXJuIGRqaW5uSWNvbjtcclxuICAgIC8vIGlmIChzb3VyY2UgPT09ICdrYXBwYScpIHJldHVybiBrYXBwYUljb247XHJcbiAgICAvLyBGb3Igbm93LCByZXR1cm4gdGhlIGRlZmF1bHQgaWNvbiBmb3IgYWxsIHNvdXJjZXNcclxuICAgIC8vIENyZWF0ZSBhIG5ldyBJY29uIGluc3RhbmNlIHdpdGggZXhwbGljaXQgb3B0aW9ucyB0byBzYXRpc2Z5IFR5cGVTY3JpcHRcclxuICAgIHJldHVybiBuZXcgTC5JY29uKHtcclxuICAgICAgICBpY29uVXJsOiBpY29uVXJsLnNyYyxcclxuICAgICAgICBpY29uUmV0aW5hVXJsOiBpY29uUmV0aW5hVXJsLnNyYyxcclxuICAgICAgICBzaGFkb3dVcmw6IHNoYWRvd1VybC5zcmMsXHJcbiAgICAgICAgaWNvblNpemU6IFsyNSwgNDFdLCAvLyBEZWZhdWx0IHNpemVcclxuICAgICAgICBpY29uQW5jaG9yOiBbMTIsIDQxXSwgLy8gRGVmYXVsdCBhbmNob3JcclxuICAgICAgICBwb3B1cEFuY2hvcjogWzEsIC0zNF0sIC8vIERlZmF1bHQgcG9wdXAgYW5jaG9yXHJcbiAgICAgICAgc2hhZG93U2l6ZTogWzQxLCA0MV0gLy8gRGVmYXVsdCBzaGFkb3cgc2l6ZVxyXG4gICAgfSk7XHJcbn1cclxuXHJcblxyXG4vLyBEZWZpbmUgYSB0eXBlIGZvciB0aGUgbWFya2VyIGRhdGEgd2UgZXhwZWN0XHJcbi8vIFRPRE86IFJlZmluZSB0aGlzIGJhc2VkIG9uIGFjdHVhbCBkYXRhIGZyb20gQVBJIEdXIChLYXBwYSwgRGppbm4sIEdob3N0LCBUZXNzZXJhY3QgRm9vdHByaW50cylcclxuaW50ZXJmYWNlIE1hcE1hcmtlckRhdGEge1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIHBvc2l0aW9uOiBbbnVtYmVyLCBudW1iZXJdOyAvLyBbbGF0aXR1ZGUsIGxvbmdpdHVkZV1cclxuICAgIHBvcHVwQ29udGVudDogc3RyaW5nO1xyXG4gICAgc291cmNlPzogJ2thcHBhJyB8ICdkamlubicgfCAnZ2hvc3QnIHwgJ3Rlc3NlcmFjdCcgfCAndGVzdCc7IC8vIE9wdGlvbmFsIHNvdXJjZSBpZGVudGlmaWVyXHJcbn1cclxuXHJcbi8vIERlZmluZSBhIHR5cGUgZm9yIHRoZSBmb290cHJpbnQgZGF0YSAoR2VvSlNPTiBGZWF0dXJlIHN0cnVjdHVyZSlcclxuLy8gTm90ZTogTGVhZmxldCdzIFBvbHlnb24gZXhwZWN0cyBjb29yZGluYXRlcyBhcyBbbGF0LCBsb25dLCB3aGlsZSBHZW9KU09OIHVzZXMgW2xvbiwgbGF0XS5cclxuLy8gV2UnbGwgbmVlZCB0byBzd2FwIHRoZW0gd2hlbiByZW5kZXJpbmcuXHJcbmludGVyZmFjZSBNYXBGb290cHJpbnREYXRhIHtcclxuICAgIHR5cGU6IFwiRmVhdHVyZVwiO1xyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIHNjZW5lX2lkOiBzdHJpbmc7XHJcbiAgICAgICAgbmFtZT86IHN0cmluZztcclxuICAgICAgICBzb3VyY2U6ICd0ZXNzZXJhY3QnOyAvLyBFeHBlY3RpbmcgZm9vdHByaW50cyBvbmx5IGZyb20gVGVzc2VyYWN0IGZvciBub3dcclxuICAgICAgICBba2V5OiBzdHJpbmddOiBhbnk7IC8vIEFsbG93IG90aGVyIHByb3BlcnRpZXNcclxuICAgIH07XHJcbiAgICBnZW9tZXRyeToge1xyXG4gICAgICAgIHR5cGU6IFwiUG9seWdvblwiO1xyXG4gICAgICAgIGNvb3JkaW5hdGVzOiBudW1iZXJbXVtdW107IC8vIFtbW2xvbiwgbGF0XSwgW2xvbiwgbGF0XSwgLi4uXV1cclxuICAgIH07XHJcbn1cclxuXHJcbi8vIEV4YW1wbGUgaW5pdGlhbCBjZW50ZXIgYW5kIHpvb21cclxuY29uc3QgZGVmYXVsdENlbnRlcjogW251bWJlciwgbnVtYmVyXSA9IFs1MS41MDUsIC0wLjA5XTsgLy8gTG9uZG9uIGNvb3JkaW5hdGVzXHJcbmNvbnN0IGRlZmF1bHRab29tID0gMTM7XHJcblxyXG5jb25zdCBTaGFyZWRNYXBDb21wb25lbnQ6IFJlYWN0LkZDID0gKCkgPT4ge1xyXG4gICAgY29uc3QgW21hcmtlcnMsIHNldE1hcmtlcnNdID0gdXNlU3RhdGU8TWFwTWFya2VyRGF0YVtdPihbXSk7XHJcbiAgICBjb25zdCBbZm9vdHByaW50cywgc2V0Rm9vdHByaW50c10gPSB1c2VTdGF0ZTxNYXBGb290cHJpbnREYXRhW10+KFtdKTsgLy8gU3RhdGUgZm9yIGZvb3RwcmludHNcclxuICAgIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbiAgICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG5cclxuICAgIC8vIFRPRE86IEltcGxlbWVudCBkYXRhIGZldGNoaW5nIGxvZ2ljXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZldGNoTWFwRGF0YSA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xyXG4gICAgICAgICAgICBzZXRFcnJvcihudWxsKTtcclxuICAgICAgICAgICAgc2V0TWFya2VycyhbXSk7IC8vIENsZWFyIHByZXZpb3VzIG1hcmtlcnNcclxuICAgICAgICAgICAgc2V0Rm9vdHByaW50cyhbXSk7IC8vIENsZWFyIHByZXZpb3VzIGZvb3RwcmludHNcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIEZldGNoIGRhdGEgZnJvbSB0aGUgYmFja2VuZCBBUEkgZW5kcG9pbnRcclxuICAgICAgICAgICAgICAgIC8vIEFzc3VtaW5nIE5leHQuanMgcHJveHkgcm91dGVzIC9hcGkvKiB0byB0aGUgYmFja2VuZCAoZS5nLiwgbG9jYWxob3N0OjgwMDApXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldCgnL2FwaS9tYXBkYXRhJyk7IC8vIFVzZSByZWxhdGl2ZSBwYXRoIGZvciBwcm94eVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgTWFya2Vyc1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGE/Lm1hcmtlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZXRjaGVkTWFya2VyczogTWFwTWFya2VyRGF0YVtdID0gcmVzcG9uc2UuZGF0YS5tYXJrZXJzLm1hcCgobTogYW55KSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbS5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG0ucG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVwQ29udGVudDogbS5wb3B1cENvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbS5zb3VyY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE1hcmtlcnMoZmV0Y2hlZE1hcmtlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IGZldGNoZWQgJHtmZXRjaGVkTWFya2Vycy5sZW5ndGh9IG1hcmtlcnMuYCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiTm8gbWFya2VyIGRhdGEgZm91bmQgaW4gcmVzcG9uc2UuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE1hcmtlcnMoW10pOyAvLyBFbnN1cmUgbWFya2VycyBhcmUgY2xlYXJlZCBpZiBub25lIGFyZSBmZXRjaGVkXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBGb290cHJpbnRzXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YT8uZm9vdHByaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJhc2ljIHZhbGlkYXRpb24gLSBjb3VsZCBiZSBtb3JlIHJvYnVzdFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoZWRGb290cHJpbnRzOiBNYXBGb290cHJpbnREYXRhW10gPSByZXNwb25zZS5kYXRhLmZvb3RwcmludHMuZmlsdGVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZjogYW55KSA9PiBmLnR5cGUgPT09IFwiRmVhdHVyZVwiICYmIGYuZ2VvbWV0cnk/LnR5cGUgPT09IFwiUG9seWdvblwiICYmIEFycmF5LmlzQXJyYXkoZi5nZW9tZXRyeS5jb29yZGluYXRlcylcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEZvb3RwcmludHMoZmV0Y2hlZEZvb3RwcmludHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IGZldGNoZWQgJHtmZXRjaGVkRm9vdHByaW50cy5sZW5ndGh9IGZvb3RwcmludHMuYCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIk5vIGZvb3RwcmludCBkYXRhIGZvdW5kIGluIHJlc3BvbnNlLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgc2V0Rm9vdHByaW50cyhbXSk7IC8vIEVuc3VyZSBmb290cHJpbnRzIGFyZSBjbGVhcmVkIGlmIG5vbmUgYXJlIGZldGNoZWRcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmRhdGE/Lm1hcmtlcnMgJiYgIXJlc3BvbnNlLmRhdGE/LmZvb3RwcmludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvciBlbXB0eSBkYXRhIGZvcm1hdCByZWNlaXZlZCBmcm9tIC9hcGkvbWFwZGF0YVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBtYXAgZGF0YTonLCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgJ0NvdWxkIG5vdCBsb2FkIG1hcCBkYXRhLicpO1xyXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZldGNoTWFwRGF0YSgpO1xyXG4gICAgfSwgW10pOyAvLyBFbXB0eSBkZXBlbmRlbmN5IGFycmF5IG1lYW5zIHRoaXMgcnVucyBvbmNlIG9uIG1vdW50XHJcblxyXG4gICAgLy8gTm90ZTogTWFwQ29udGFpbmVyIG5lZWRzIGEgZGVmaW5lZCBoZWlnaHQvd2lkdGggdmlhIENTUyB0byBiZSB2aXNpYmxlLlxyXG4gICAgLy8gRW5zdXJlIHRoZSBwYXJlbnQgY29udGFpbmVyIG9yIGEgQ1NTIHJ1bGUgcHJvdmlkZXMgdGhpcy5cclxuICAgIC8vIEV4YW1wbGU6IHN0eWxlPXt7IGhlaWdodDogJzUwMHB4Jywgd2lkdGg6ICcxMDAlJyB9fVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBzdHlsZT17eyBoZWlnaHQ6ICc2MDBweCcsIHdpZHRoOiAnMTAwJScsIGJvcmRlcjogJzFweCBzb2xpZCAjY2NjJyB9fT5cclxuICAgICAgICAgICAgIHsvKiBDaGVjayBpZiB3aW5kb3cgaXMgZGVmaW5lZCBmb3IgU1NSIHNhZmV0eSwgYWx0aG91Z2ggTWFwQ29udGFpbmVyIGhhbmRsZXMgbXVjaCBvZiB0aGlzICovfVxyXG4gICAgICAgICAgICB7dHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxyXG4gICAgICAgICAgICAgICAgPE1hcENvbnRhaW5lciBjZW50ZXI9e2RlZmF1bHRDZW50ZXJ9IHpvb209e2RlZmF1bHRab29tfSBzY3JvbGxXaGVlbFpvb209e3RydWV9IHN0eWxlPXt7IGhlaWdodDogJzEwMCUnLCB3aWR0aDogJzEwMCUnIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIDxUaWxlTGF5ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRpb249JyZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw9XCJodHRwczovL3tzfS50aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAge2lzTG9hZGluZyAmJiA8cD5Mb2FkaW5nIG1hcCBkYXRhLi4uPC9wPn1cclxuICAgICAgICAgICAgICAgICAgICB7ZXJyb3IgJiYgPHAgc3R5bGU9e3sgY29sb3I6ICdyZWQnIH19PkVycm9yOiB7ZXJyb3J9PC9wPn1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeyFpc0xvYWRpbmcgJiYgbWFya2Vycy5tYXAoKG1hcmtlcikgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TWFya2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e21hcmtlci5pZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uPXttYXJrZXIucG9zaXRpb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPXtnZXRJY29uRm9yU291cmNlKG1hcmtlci5zb3VyY2UpfSAvLyBVc2UgY3VzdG9tIGljb24gYmFzZWQgb24gc291cmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxQb3B1cD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bWFya2VyLnBvcHVwQ29udGVudH0gPGJyIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsPlNvdXJjZToge21hcmtlci5zb3VyY2UgfHwgJ1Vua25vd24nfTwvc21hbGw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L1BvcHVwPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L01hcmtlcj5cclxuICAgICAgICAgICAgICAgICAgICApKX1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgey8qIFJlbmRlciBUZXNzZXJhY3QgRm9vdHByaW50cyAqL31cclxuICAgICAgICAgICAgICAgICAgICB7IWlzTG9hZGluZyAmJiBmb290cHJpbnRzLm1hcCgoZm9vdHByaW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElNUE9SVEFOVDogU3dhcCBHZW9KU09OIFtsb24sIGxhdF0gdG8gTGVhZmxldCBbbGF0LCBsb25dXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IGZvb3RwcmludC5nZW9tZXRyeS5jb29yZGluYXRlc1swXS5tYXAoY29vcmQgPT4gW2Nvb3JkWzFdLCBjb29yZFswXV0gYXMgW251bWJlciwgbnVtYmVyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjZW5lSWQgPSBmb290cHJpbnQucHJvcGVydGllcy5zY2VuZV9pZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGZvb3RwcmludC5wcm9wZXJ0aWVzLm5hbWUgfHwgYFNjZW5lICR7c2NlbmVJZH1gO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxQb2x5Z29uIGtleT17c2NlbmVJZH0gcGF0aE9wdGlvbnM9e3sgY29sb3I6ICdwdXJwbGUnIH19IHBvc2l0aW9ucz17cG9zaXRpb25zfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UG9wdXA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRlc3NlcmFjdCBGb290cHJpbnQ6IHtuYW1lfSA8YnIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2NlbmUgSUQ6IHtzY2VuZUlkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7LyogVE9ETzogQWRkIGxpbmsgdG8gVGVzc2VyYWN0IDNEIHZpZXdlciAqL31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L1BvcHVwPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9Qb2x5Z29uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pfVxyXG4gICAgICAgICAgICAgICAgPC9NYXBDb250YWluZXI+XHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59O1xyXG5cclxuLy8gQWRkIGxvZ2dlciBpbnN0YW5jZSBpZiBuZWVkZWRcclxuY29uc3QgbG9nZ2VyID0ge1xyXG4gICAgZXJyb3I6ICguLi5hcmdzOiBhbnlbXSkgPT4gY29uc29sZS5lcnJvciguLi5hcmdzKSxcclxuICAgIGRlYnVnOiAoLi4uYXJnczogYW55W10pID0+IGNvbnNvbGUubG9nKC4uLmFyZ3MpLFxyXG4gICAgd2FybjogKC4uLmFyZ3M6IGFueVtdKSA9PiBjb25zb2xlLndhcm4oLi4uYXJncyksXHJcbn07XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2hhcmVkTWFwQ29tcG9uZW50OyJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiTWFwQ29udGFpbmVyIiwiVGlsZUxheWVyIiwiTWFya2VyIiwiUG9wdXAiLCJQb2x5Z29uIiwiTCIsImF4aW9zIiwiaWNvblJldGluYVVybCIsImljb25VcmwiLCJzaGFkb3dVcmwiLCJJY29uIiwiRGVmYXVsdCIsInByb3RvdHlwZSIsIl9nZXRJY29uVXJsIiwibWVyZ2VPcHRpb25zIiwic3JjIiwiZ2V0SWNvbkZvclNvdXJjZSIsInNvdXJjZSIsImljb25TaXplIiwiaWNvbkFuY2hvciIsInBvcHVwQW5jaG9yIiwic2hhZG93U2l6ZSIsImRlZmF1bHRDZW50ZXIiLCJkZWZhdWx0Wm9vbSIsIlNoYXJlZE1hcENvbXBvbmVudCIsIm1hcmtlcnMiLCJzZXRNYXJrZXJzIiwiZm9vdHByaW50cyIsInNldEZvb3RwcmludHMiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwiZmV0Y2hNYXBEYXRhIiwicmVzcG9uc2UiLCJnZXQiLCJkYXRhIiwiZmV0Y2hlZE1hcmtlcnMiLCJtYXAiLCJtIiwiaWQiLCJwb3NpdGlvbiIsInBvcHVwQ29udGVudCIsImxvZ2dlciIsImRlYnVnIiwibGVuZ3RoIiwid2FybiIsImZldGNoZWRGb290cHJpbnRzIiwiZmlsdGVyIiwiZiIsInR5cGUiLCJnZW9tZXRyeSIsIkFycmF5IiwiaXNBcnJheSIsImNvb3JkaW5hdGVzIiwiRXJyb3IiLCJlcnIiLCJtZXNzYWdlIiwiZGl2Iiwic3R5bGUiLCJoZWlnaHQiLCJ3aWR0aCIsImJvcmRlciIsImNlbnRlciIsInpvb20iLCJzY3JvbGxXaGVlbFpvb20iLCJhdHRyaWJ1dGlvbiIsInVybCIsInAiLCJjb2xvciIsIm1hcmtlciIsImljb24iLCJiciIsInNtYWxsIiwiZm9vdHByaW50IiwicG9zaXRpb25zIiwiY29vcmQiLCJzY2VuZUlkIiwicHJvcGVydGllcyIsInNjZW5lX2lkIiwibmFtZSIsInBhdGhPcHRpb25zIiwiYXJncyIsImNvbnNvbGUiLCJsb2ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/map/SharedMapComponent.tsx\n");

/***/ })

};
;