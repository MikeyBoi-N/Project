"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "components_map_SharedMapComponent_tsx";
exports.ids = ["components_map_SharedMapComponent_tsx"];
exports.modules = {

/***/ "./components/map/SharedMapComponent.tsx":
/*!***********************************************!*\
  !*** ./components/map/SharedMapComponent.tsx ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-leaflet */ \"react-leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"axios\");\n/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! leaflet/dist/leaflet.css */ \"./node_modules/leaflet/dist/leaflet.css\");\n/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var leaflet_dist_images_marker_icon_2x_png__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! leaflet/dist/images/marker-icon-2x.png */ \"./node_modules/leaflet/dist/images/marker-icon-2x.png\");\n/* harmony import */ var leaflet_dist_images_marker_icon_png__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! leaflet/dist/images/marker-icon.png */ \"./node_modules/leaflet/dist/images/marker-icon.png\");\n/* harmony import */ var leaflet_dist_images_marker_shadow_png__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! leaflet/dist/images/marker-shadow.png */ \"./node_modules/leaflet/dist/images/marker-shadow.png\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([react_leaflet__WEBPACK_IMPORTED_MODULE_2__, axios__WEBPACK_IMPORTED_MODULE_4__]);\n([react_leaflet__WEBPACK_IMPORTED_MODULE_2__, axios__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n // Added Polygon\n\n // Import axios for API calls\n // Import Leaflet CSS\n// Fix for default marker icon issue with webpack/Next.js\n// (See: https://github.com/PaulLeCam/react-leaflet/issues/808)\n\n\n\n// Explicitly set the default icon paths\ndelete (leaflet__WEBPACK_IMPORTED_MODULE_3___default().Icon).Default.prototype._getIconUrl; // Type assertion needed\nleaflet__WEBPACK_IMPORTED_MODULE_3___default().Icon.Default.mergeOptions({\n    iconRetinaUrl: leaflet_dist_images_marker_icon_2x_png__WEBPACK_IMPORTED_MODULE_6__[\"default\"].src,\n    iconUrl: leaflet_dist_images_marker_icon_png__WEBPACK_IMPORTED_MODULE_7__[\"default\"].src,\n    shadowUrl: leaflet_dist_images_marker_shadow_png__WEBPACK_IMPORTED_MODULE_8__[\"default\"].src\n});\n// Function to get a specific icon based on the source\n// TODO: Define custom icons for different sources (Kappa, Djinn, Ghost, etc.)\nfunction getIconForSource(source) {\n    // Example: Return different icons based on source\n    // if (source === 'djinn') return djinnIcon;\n    // if (source === 'kappa') return kappaIcon;\n    // For now, return the default icon for all sources\n    // Create a new Icon instance with explicit options to satisfy TypeScript\n    return new (leaflet__WEBPACK_IMPORTED_MODULE_3___default().Icon)({\n        iconUrl: leaflet_dist_images_marker_icon_png__WEBPACK_IMPORTED_MODULE_7__[\"default\"].src,\n        iconRetinaUrl: leaflet_dist_images_marker_icon_2x_png__WEBPACK_IMPORTED_MODULE_6__[\"default\"].src,\n        shadowUrl: leaflet_dist_images_marker_shadow_png__WEBPACK_IMPORTED_MODULE_8__[\"default\"].src,\n        iconSize: [\n            25,\n            41\n        ],\n        iconAnchor: [\n            12,\n            41\n        ],\n        popupAnchor: [\n            1,\n            -34\n        ],\n        shadowSize: [\n            41,\n            41\n        ] // Default shadow size\n    });\n}\n// Example initial center and zoom\nconst defaultCenter = [\n    51.505,\n    -0.09\n]; // London coordinates\nconst defaultZoom = 13;\nconst SharedMapComponent = ()=>{\n    const [markers, setMarkers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [footprints, setFootprints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]); // State for footprints\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // TODO: Implement data fetching logic\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const fetchMapData = async ()=>{\n            setIsLoading(true);\n            setError(null);\n            setMarkers([]); // Clear previous markers\n            setFootprints([]); // Clear previous footprints\n            try {\n                // Fetch data from the backend API endpoint\n                // Assuming Next.js proxy routes /api/* to the backend (e.g., localhost:8000)\n                const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"/api/mapdata\"); // Use relative path for proxy\n                // Process Markers\n                if (response.data?.markers) {\n                    const fetchedMarkers = response.data.markers.map((m)=>({\n                            id: m.id,\n                            position: m.position,\n                            popupContent: m.popupContent,\n                            source: m.source\n                        }));\n                    setMarkers(fetchedMarkers);\n                    logger.debug(`Successfully fetched ${fetchedMarkers.length} markers.`);\n                } else {\n                    logger.warn(\"No marker data found in response.\");\n                    setMarkers([]); // Ensure markers are cleared if none are fetched\n                }\n                // Process Footprints\n                if (response.data?.footprints) {\n                    // Basic validation - could be more robust\n                    const fetchedFootprints = response.data.footprints.filter((f)=>f.type === \"Feature\" && f.geometry?.type === \"Polygon\" && Array.isArray(f.geometry.coordinates));\n                    setFootprints(fetchedFootprints);\n                    logger.debug(`Successfully fetched ${fetchedFootprints.length} footprints.`);\n                } else {\n                    logger.warn(\"No footprint data found in response.\");\n                    setFootprints([]); // Ensure footprints are cleared if none are fetched\n                }\n                if (!response.data?.markers && !response.data?.footprints) {\n                    throw new Error(\"Invalid or empty data format received from /api/mapdata\");\n                }\n            } catch (err) {\n                logger.error(\"Failed to fetch map data:\", err);\n                setError(err.message || \"Could not load map data.\");\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        fetchMapData();\n    }, []); // Empty dependency array means this runs once on mount\n    // Note: MapContainer needs a defined height/width via CSS to be visible.\n    // Ensure the parent container or a CSS rule provides this.\n    // Example: style={{ height: '500px', width: '100%' }}\n    // State for theme\n    const [isDarkMode, setIsDarkMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true); // Default to dark mode\n    return(// This component now expects its parent (.pageContent) to manage layout.\n    // We use a React Fragment <> or a div that grows to fill the space.\n    // Let's use a div that grows to ensure it fills the flex container.\n    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            flexGrow: 1,\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100%\"\n        },\n        children: [\n             false && /*#__PURE__*/ 0,\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: ()=>setIsDarkMode(!isDarkMode),\n                style: {\n                    position: \"absolute\",\n                    bottom: \"80px\",\n                    right: \"10px\",\n                    zIndex: 1000,\n                    padding: \"8px 12px\",\n                    backgroundColor: \"rgba(0, 0, 0, 0.7)\",\n                    color: \"white\",\n                    border: \"1px solid #555\",\n                    borderRadius: \"4px\",\n                    cursor: \"pointer\",\n                    fontSize: \"12px\"\n                },\n                children: [\n                    isDarkMode ? \"Light\" : \"Dark\",\n                    \" Mode\"\n                ]\n            }, void 0, true, {\n                fileName: \"F:\\\\Selkie\\\\Project\\\\frontend\\\\components\\\\map\\\\SharedMapComponent.tsx\",\n                lineNumber: 201,\n                columnNumber: 13\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"F:\\\\Selkie\\\\Project\\\\frontend\\\\components\\\\map\\\\SharedMapComponent.tsx\",\n        lineNumber: 142,\n        columnNumber: 9\n    }, undefined));\n};\n// Add logger instance if needed\nconst logger = {\n    error: (...args)=>console.error(...args),\n    debug: (...args)=>console.log(...args),\n    warn: (...args)=>console.warn(...args)\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SharedMapComponent);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O29CQUNSQyxVQUFVO2dCQUNkOztvQkFFQ3JDLGFBQWEsVUFBVTtvQkFBTzs7Ozs7Ozs7Ozs7OztBQUkvQztBQUVBLGdDQUFnQztBQUNoQyxNQUFNZixTQUFTO0lBQ1haLE9BQU8sQ0FBQyxHQUFHaUUsT0FBZ0JDLFFBQVFsRSxLQUFLLElBQUlpRTtJQUM1Q3BELE9BQU8sQ0FBQyxHQUFHb0QsT0FBZ0JDLFFBQVFDLEdBQUcsSUFBSUY7SUFDMUNsRCxNQUFNLENBQUMsR0FBR2tELE9BQWdCQyxRQUFRbkQsSUFBSSxJQUFJa0Q7QUFDOUM7QUFHQSxpRUFBZXhFLGtCQUFrQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NlbGtpZS1mcm9udGVuZC8uL2NvbXBvbmVudHMvbWFwL1NoYXJlZE1hcENvbXBvbmVudC50c3g/YzhjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgTWFwQ29udGFpbmVyLCBUaWxlTGF5ZXIsIE1hcmtlciwgUG9wdXAsIFBvbHlnb24gfSBmcm9tICdyZWFjdC1sZWFmbGV0JzsgLy8gQWRkZWQgUG9seWdvblxyXG5pbXBvcnQgTCBmcm9tICdsZWFmbGV0JztcclxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJzsgLy8gSW1wb3J0IGF4aW9zIGZvciBBUEkgY2FsbHNcclxuaW1wb3J0ICdsZWFmbGV0L2Rpc3QvbGVhZmxldC5jc3MnOyAvLyBJbXBvcnQgTGVhZmxldCBDU1NcclxuXHJcbi8vIEZpeCBmb3IgZGVmYXVsdCBtYXJrZXIgaWNvbiBpc3N1ZSB3aXRoIHdlYnBhY2svTmV4dC5qc1xyXG4vLyAoU2VlOiBodHRwczovL2dpdGh1Yi5jb20vUGF1bExlQ2FtL3JlYWN0LWxlYWZsZXQvaXNzdWVzLzgwOClcclxuaW1wb3J0IGljb25SZXRpbmFVcmwgZnJvbSAnbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItaWNvbi0yeC5wbmcnO1xyXG5pbXBvcnQgaWNvblVybCBmcm9tICdsZWFmbGV0L2Rpc3QvaW1hZ2VzL21hcmtlci1pY29uLnBuZyc7XHJcbmltcG9ydCBzaGFkb3dVcmwgZnJvbSAnbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItc2hhZG93LnBuZyc7XHJcblxyXG4vLyBFeHBsaWNpdGx5IHNldCB0aGUgZGVmYXVsdCBpY29uIHBhdGhzXHJcbmRlbGV0ZSAoTC5JY29uLkRlZmF1bHQucHJvdG90eXBlIGFzIGFueSkuX2dldEljb25Vcmw7IC8vIFR5cGUgYXNzZXJ0aW9uIG5lZWRlZFxyXG5MLkljb24uRGVmYXVsdC5tZXJnZU9wdGlvbnMoe1xyXG4gICAgaWNvblJldGluYVVybDogaWNvblJldGluYVVybC5zcmMsXHJcbiAgICBpY29uVXJsOiBpY29uVXJsLnNyYyxcclxuICAgIHNoYWRvd1VybDogc2hhZG93VXJsLnNyYyxcclxufSk7XHJcbi8vIEZ1bmN0aW9uIHRvIGdldCBhIHNwZWNpZmljIGljb24gYmFzZWQgb24gdGhlIHNvdXJjZVxyXG4vLyBUT0RPOiBEZWZpbmUgY3VzdG9tIGljb25zIGZvciBkaWZmZXJlbnQgc291cmNlcyAoS2FwcGEsIERqaW5uLCBHaG9zdCwgZXRjLilcclxuZnVuY3Rpb24gZ2V0SWNvbkZvclNvdXJjZShzb3VyY2U/OiBNYXBNYXJrZXJEYXRhWydzb3VyY2UnXSk6IEwuSWNvbiB7XHJcbiAgICAvLyBFeGFtcGxlOiBSZXR1cm4gZGlmZmVyZW50IGljb25zIGJhc2VkIG9uIHNvdXJjZVxyXG4gICAgLy8gaWYgKHNvdXJjZSA9PT0gJ2RqaW5uJykgcmV0dXJuIGRqaW5uSWNvbjtcclxuICAgIC8vIGlmIChzb3VyY2UgPT09ICdrYXBwYScpIHJldHVybiBrYXBwYUljb247XHJcbiAgICAvLyBGb3Igbm93LCByZXR1cm4gdGhlIGRlZmF1bHQgaWNvbiBmb3IgYWxsIHNvdXJjZXNcclxuICAgIC8vIENyZWF0ZSBhIG5ldyBJY29uIGluc3RhbmNlIHdpdGggZXhwbGljaXQgb3B0aW9ucyB0byBzYXRpc2Z5IFR5cGVTY3JpcHRcclxuICAgIHJldHVybiBuZXcgTC5JY29uKHtcclxuICAgICAgICBpY29uVXJsOiBpY29uVXJsLnNyYyxcclxuICAgICAgICBpY29uUmV0aW5hVXJsOiBpY29uUmV0aW5hVXJsLnNyYyxcclxuICAgICAgICBzaGFkb3dVcmw6IHNoYWRvd1VybC5zcmMsXHJcbiAgICAgICAgaWNvblNpemU6IFsyNSwgNDFdLCAvLyBEZWZhdWx0IHNpemVcclxuICAgICAgICBpY29uQW5jaG9yOiBbMTIsIDQxXSwgLy8gRGVmYXVsdCBhbmNob3JcclxuICAgICAgICBwb3B1cEFuY2hvcjogWzEsIC0zNF0sIC8vIERlZmF1bHQgcG9wdXAgYW5jaG9yXHJcbiAgICAgICAgc2hhZG93U2l6ZTogWzQxLCA0MV0gLy8gRGVmYXVsdCBzaGFkb3cgc2l6ZVxyXG4gICAgfSk7XHJcbn1cclxuXHJcblxyXG4vLyBEZWZpbmUgYSB0eXBlIGZvciB0aGUgbWFya2VyIGRhdGEgd2UgZXhwZWN0XHJcbi8vIFRPRE86IFJlZmluZSB0aGlzIGJhc2VkIG9uIGFjdHVhbCBkYXRhIGZyb20gQVBJIEdXIChLYXBwYSwgRGppbm4sIEdob3N0LCBUZXNzZXJhY3QgRm9vdHByaW50cylcclxuaW50ZXJmYWNlIE1hcE1hcmtlckRhdGEge1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIHBvc2l0aW9uOiBbbnVtYmVyLCBudW1iZXJdOyAvLyBbbGF0aXR1ZGUsIGxvbmdpdHVkZV1cclxuICAgIHBvcHVwQ29udGVudDogc3RyaW5nO1xyXG4gICAgc291cmNlPzogJ2thcHBhJyB8ICdkamlubicgfCAnZ2hvc3QnIHwgJ3Rlc3NlcmFjdCcgfCAndGVzdCc7IC8vIE9wdGlvbmFsIHNvdXJjZSBpZGVudGlmaWVyXHJcbn1cclxuXHJcbi8vIERlZmluZSBhIHR5cGUgZm9yIHRoZSBmb290cHJpbnQgZGF0YSAoR2VvSlNPTiBGZWF0dXJlIHN0cnVjdHVyZSlcclxuLy8gTm90ZTogTGVhZmxldCdzIFBvbHlnb24gZXhwZWN0cyBjb29yZGluYXRlcyBhcyBbbGF0LCBsb25dLCB3aGlsZSBHZW9KU09OIHVzZXMgW2xvbiwgbGF0XS5cclxuLy8gV2UnbGwgbmVlZCB0byBzd2FwIHRoZW0gd2hlbiByZW5kZXJpbmcuXHJcbmludGVyZmFjZSBNYXBGb290cHJpbnREYXRhIHtcclxuICAgIHR5cGU6IFwiRmVhdHVyZVwiO1xyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIHNjZW5lX2lkOiBzdHJpbmc7XHJcbiAgICAgICAgbmFtZT86IHN0cmluZztcclxuICAgICAgICBzb3VyY2U6ICd0ZXNzZXJhY3QnOyAvLyBFeHBlY3RpbmcgZm9vdHByaW50cyBvbmx5IGZyb20gVGVzc2VyYWN0IGZvciBub3dcclxuICAgICAgICBba2V5OiBzdHJpbmddOiBhbnk7IC8vIEFsbG93IG90aGVyIHByb3BlcnRpZXNcclxuICAgIH07XHJcbiAgICBnZW9tZXRyeToge1xyXG4gICAgICAgIHR5cGU6IFwiUG9seWdvblwiO1xyXG4gICAgICAgIGNvb3JkaW5hdGVzOiBudW1iZXJbXVtdW107IC8vIFtbW2xvbiwgbGF0XSwgW2xvbiwgbGF0XSwgLi4uXV1cclxuICAgIH07XHJcbn1cclxuXHJcbi8vIEV4YW1wbGUgaW5pdGlhbCBjZW50ZXIgYW5kIHpvb21cclxuY29uc3QgZGVmYXVsdENlbnRlcjogW251bWJlciwgbnVtYmVyXSA9IFs1MS41MDUsIC0wLjA5XTsgLy8gTG9uZG9uIGNvb3JkaW5hdGVzXHJcbmNvbnN0IGRlZmF1bHRab29tID0gMTM7XHJcblxyXG5jb25zdCBTaGFyZWRNYXBDb21wb25lbnQ6IFJlYWN0LkZDID0gKCkgPT4ge1xyXG4gICAgY29uc3QgW21hcmtlcnMsIHNldE1hcmtlcnNdID0gdXNlU3RhdGU8TWFwTWFya2VyRGF0YVtdPihbXSk7XHJcbiAgICBjb25zdCBbZm9vdHByaW50cywgc2V0Rm9vdHByaW50c10gPSB1c2VTdGF0ZTxNYXBGb290cHJpbnREYXRhW10+KFtdKTsgLy8gU3RhdGUgZm9yIGZvb3RwcmludHNcclxuICAgIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbiAgICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG5cclxuICAgIC8vIFRPRE86IEltcGxlbWVudCBkYXRhIGZldGNoaW5nIGxvZ2ljXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZldGNoTWFwRGF0YSA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xyXG4gICAgICAgICAgICBzZXRFcnJvcihudWxsKTtcclxuICAgICAgICAgICAgc2V0TWFya2VycyhbXSk7IC8vIENsZWFyIHByZXZpb3VzIG1hcmtlcnNcclxuICAgICAgICAgICAgc2V0Rm9vdHByaW50cyhbXSk7IC8vIENsZWFyIHByZXZpb3VzIGZvb3RwcmludHNcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIEZldGNoIGRhdGEgZnJvbSB0aGUgYmFja2VuZCBBUEkgZW5kcG9pbnRcclxuICAgICAgICAgICAgICAgIC8vIEFzc3VtaW5nIE5leHQuanMgcHJveHkgcm91dGVzIC9hcGkvKiB0byB0aGUgYmFja2VuZCAoZS5nLiwgbG9jYWxob3N0OjgwMDApXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldCgnL2FwaS9tYXBkYXRhJyk7IC8vIFVzZSByZWxhdGl2ZSBwYXRoIGZvciBwcm94eVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgTWFya2Vyc1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGE/Lm1hcmtlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZXRjaGVkTWFya2VyczogTWFwTWFya2VyRGF0YVtdID0gcmVzcG9uc2UuZGF0YS5tYXJrZXJzLm1hcCgobTogYW55KSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbS5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG0ucG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVwQ29udGVudDogbS5wb3B1cENvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbS5zb3VyY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE1hcmtlcnMoZmV0Y2hlZE1hcmtlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IGZldGNoZWQgJHtmZXRjaGVkTWFya2Vycy5sZW5ndGh9IG1hcmtlcnMuYCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiTm8gbWFya2VyIGRhdGEgZm91bmQgaW4gcmVzcG9uc2UuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE1hcmtlcnMoW10pOyAvLyBFbnN1cmUgbWFya2VycyBhcmUgY2xlYXJlZCBpZiBub25lIGFyZSBmZXRjaGVkXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBGb290cHJpbnRzXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YT8uZm9vdHByaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJhc2ljIHZhbGlkYXRpb24gLSBjb3VsZCBiZSBtb3JlIHJvYnVzdFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoZWRGb290cHJpbnRzOiBNYXBGb290cHJpbnREYXRhW10gPSByZXNwb25zZS5kYXRhLmZvb3RwcmludHMuZmlsdGVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZjogYW55KSA9PiBmLnR5cGUgPT09IFwiRmVhdHVyZVwiICYmIGYuZ2VvbWV0cnk/LnR5cGUgPT09IFwiUG9seWdvblwiICYmIEFycmF5LmlzQXJyYXkoZi5nZW9tZXRyeS5jb29yZGluYXRlcylcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEZvb3RwcmludHMoZmV0Y2hlZEZvb3RwcmludHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IGZldGNoZWQgJHtmZXRjaGVkRm9vdHByaW50cy5sZW5ndGh9IGZvb3RwcmludHMuYCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIk5vIGZvb3RwcmludCBkYXRhIGZvdW5kIGluIHJlc3BvbnNlLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgc2V0Rm9vdHByaW50cyhbXSk7IC8vIEVuc3VyZSBmb290cHJpbnRzIGFyZSBjbGVhcmVkIGlmIG5vbmUgYXJlIGZldGNoZWRcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmRhdGE/Lm1hcmtlcnMgJiYgIXJlc3BvbnNlLmRhdGE/LmZvb3RwcmludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvciBlbXB0eSBkYXRhIGZvcm1hdCByZWNlaXZlZCBmcm9tIC9hcGkvbWFwZGF0YVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBtYXAgZGF0YTonLCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgJ0NvdWxkIG5vdCBsb2FkIG1hcCBkYXRhLicpO1xyXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZldGNoTWFwRGF0YSgpO1xyXG4gICAgfSwgW10pOyAvLyBFbXB0eSBkZXBlbmRlbmN5IGFycmF5IG1lYW5zIHRoaXMgcnVucyBvbmNlIG9uIG1vdW50XHJcblxyXG4gICAgLy8gTm90ZTogTWFwQ29udGFpbmVyIG5lZWRzIGEgZGVmaW5lZCBoZWlnaHQvd2lkdGggdmlhIENTUyB0byBiZSB2aXNpYmxlLlxyXG4gICAgLy8gRW5zdXJlIHRoZSBwYXJlbnQgY29udGFpbmVyIG9yIGEgQ1NTIHJ1bGUgcHJvdmlkZXMgdGhpcy5cclxuICAgIC8vIEV4YW1wbGU6IHN0eWxlPXt7IGhlaWdodDogJzUwMHB4Jywgd2lkdGg6ICcxMDAlJyB9fVxyXG5cclxuICAgIC8vIFN0YXRlIGZvciB0aGVtZVxyXG4gICAgY29uc3QgW2lzRGFya01vZGUsIHNldElzRGFya01vZGVdID0gdXNlU3RhdGUodHJ1ZSk7IC8vIERlZmF1bHQgdG8gZGFyayBtb2RlXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICAvLyBUaGlzIGNvbXBvbmVudCBub3cgZXhwZWN0cyBpdHMgcGFyZW50ICgucGFnZUNvbnRlbnQpIHRvIG1hbmFnZSBsYXlvdXQuXHJcbiAgICAgICAgLy8gV2UgdXNlIGEgUmVhY3QgRnJhZ21lbnQgPD4gb3IgYSBkaXYgdGhhdCBncm93cyB0byBmaWxsIHRoZSBzcGFjZS5cclxuICAgICAgICAvLyBMZXQncyB1c2UgYSBkaXYgdGhhdCBncm93cyB0byBlbnN1cmUgaXQgZmlsbHMgdGhlIGZsZXggY29udGFpbmVyLlxyXG4gICAgICAgIDxkaXYgc3R5bGU9e3sgZmxleEdyb3c6IDEsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJyB9fT5cclxuICAgICAgICAgICAgIHsvKiBDaGVjayBpZiB3aW5kb3cgaXMgZGVmaW5lZCBmb3IgU1NSIHNhZmV0eSwgYWx0aG91Z2ggTWFwQ29udGFpbmVyIGhhbmRsZXMgbXVjaCBvZiB0aGlzICovfVxyXG4gICAgICAgICAgICB7dHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxyXG4gICAgICAgICAgICAgICAgPE1hcENvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlcj17ZGVmYXVsdENlbnRlcn1cclxuICAgICAgICAgICAgICAgICAgICB6b29tPXtkZWZhdWx0Wm9vbX1cclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxXaGVlbFpvb209e3RydWV9XHJcbiAgICAgICAgICAgICAgICAgICAgem9vbUNvbnRyb2w9e2ZhbHNlfSAvLyBEaXNhYmxlIGRlZmF1bHQgTGVhZmxldCB6b29tIGNvbnRyb2xzXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgaGVpZ2h0OiAnMTAwJScsIHdpZHRoOiAnMTAwJScgfX0gLy8gTWFwIGZpbGxzIHRoZSBjb250YWluZXIgZGl2XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgey8qIENvbmRpdGlvbmFsbHkgcmVuZGVyIFRpbGVMYXllciBiYXNlZCBvbiB0aGVtZSAqL31cclxuICAgICAgICAgICAgICAgICAgICB7aXNEYXJrTW9kZSA/IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRpbGVMYXllclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRpb249JyZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzICZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly9jYXJ0by5jb20vYXR0cmlidXRpb25zXCI+Q0FSVE88L2E+J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsPVwiaHR0cHM6Ly97c30uYmFzZW1hcHMuY2FydG9jZG4uY29tL2RhcmtfYWxsL3t6fS97eH0ve3l9e3J9LnBuZ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgKSA6IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPFRpbGVMYXllclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRpb249JyZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsPVwiaHR0cHM6Ly97c30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmdcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICl9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHtpc0xvYWRpbmcgJiYgPHA+TG9hZGluZyBtYXAgZGF0YS4uLjwvcD59XHJcbiAgICAgICAgICAgICAgICAgICAge2Vycm9yICYmIDxwIHN0eWxlPXt7IGNvbG9yOiAncmVkJyB9fT5FcnJvcjoge2Vycm9yfTwvcD59XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHshaXNMb2FkaW5nICYmIG1hcmtlcnMubWFwKChtYXJrZXIpID0+IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPE1hcmtlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXttYXJrZXIuaWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbj17bWFya2VyLnBvc2l0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj17Z2V0SWNvbkZvclNvdXJjZShtYXJrZXIuc291cmNlKX0gLy8gVXNlIGN1c3RvbSBpY29uIGJhc2VkIG9uIHNvdXJjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UG9wdXA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge21hcmtlci5wb3B1cENvbnRlbnR9IDxiciAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbD5Tb3VyY2U6IHttYXJrZXIuc291cmNlIHx8ICdVbmtub3duJ308L3NtYWxsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9Qb3B1cD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9NYXJrZXI+XHJcbiAgICAgICAgICAgICAgICAgICAgKSl9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHsvKiBSZW5kZXIgVGVzc2VyYWN0IEZvb3RwcmludHMgKi99XHJcbiAgICAgICAgICAgICAgICAgICAgeyFpc0xvYWRpbmcgJiYgZm9vdHByaW50cy5tYXAoKGZvb3RwcmludCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IFN3YXAgR2VvSlNPTiBbbG9uLCBsYXRdIHRvIExlYWZsZXQgW2xhdCwgbG9uXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBmb290cHJpbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0ubWFwKGNvb3JkID0+IFtjb29yZFsxXSwgY29vcmRbMF1dIGFzIFtudW1iZXIsIG51bWJlcl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2VuZUlkID0gZm9vdHByaW50LnByb3BlcnRpZXMuc2NlbmVfaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBmb290cHJpbnQucHJvcGVydGllcy5uYW1lIHx8IGBTY2VuZSAke3NjZW5lSWR9YDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UG9seWdvbiBrZXk9e3NjZW5lSWR9IHBhdGhPcHRpb25zPXt7IGNvbG9yOiAncHVycGxlJyB9fSBwb3NpdGlvbnM9e3Bvc2l0aW9uc30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFBvcHVwPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUZXNzZXJhY3QgRm9vdHByaW50OiB7bmFtZX0gPGJyIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNjZW5lIElEOiB7c2NlbmVJZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey8qIFRPRE86IEFkZCBsaW5rIHRvIFRlc3NlcmFjdCAzRCB2aWV3ZXIgKi99XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9Qb3B1cD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvUG9seWdvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9KX1cclxuICAgICAgICAgICAgICAgIDwvTWFwQ29udGFpbmVyPlxyXG4gICAgICAgICAgICApfVxyXG4gICAgICAgICAgICB7LyogVGhlbWUgVG9nZ2xlIEJ1dHRvbiAtIFBvc2l0aW9uZWQgYWJzb2x1dGVseSAqL31cclxuICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0SXNEYXJrTW9kZSghaXNEYXJrTW9kZSl9XHJcbiAgICAgICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogJzgwcHgnLCAvLyBQb3NpdGlvbiBhYm92ZSBkZWZhdWx0IHpvb20gcGxhY2Vob2xkZXJzIGZvciBub3dcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogJzEwcHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogMTAwMCwgLy8gRW5zdXJlIGl0J3MgYWJvdmUgbWFwIGxheWVyc1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTJweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjcpJyxcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcclxuICAgICAgICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxyXG4gICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAge2lzRGFya01vZGUgPyAnTGlnaHQnIDogJ0RhcmsnfSBNb2RlXHJcbiAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufTtcclxuXHJcbi8vIEFkZCBsb2dnZXIgaW5zdGFuY2UgaWYgbmVlZGVkXHJcbmNvbnN0IGxvZ2dlciA9IHtcclxuICAgIGVycm9yOiAoLi4uYXJnczogYW55W10pID0+IGNvbnNvbGUuZXJyb3IoLi4uYXJncyksXHJcbiAgICBkZWJ1ZzogKC4uLmFyZ3M6IGFueVtdKSA9PiBjb25zb2xlLmxvZyguLi5hcmdzKSxcclxuICAgIHdhcm46ICguLi5hcmdzOiBhbnlbXSkgPT4gY29uc29sZS53YXJuKC4uLmFyZ3MpLFxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNoYXJlZE1hcENvbXBvbmVudDsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsIk1hcENvbnRhaW5lciIsIlRpbGVMYXllciIsIk1hcmtlciIsIlBvcHVwIiwiUG9seWdvbiIsIkwiLCJheGlvcyIsImljb25SZXRpbmFVcmwiLCJpY29uVXJsIiwic2hhZG93VXJsIiwiSWNvbiIsIkRlZmF1bHQiLCJwcm90b3R5cGUiLCJfZ2V0SWNvblVybCIsIm1lcmdlT3B0aW9ucyIsInNyYyIsImdldEljb25Gb3JTb3VyY2UiLCJzb3VyY2UiLCJpY29uU2l6ZSIsImljb25BbmNob3IiLCJwb3B1cEFuY2hvciIsInNoYWRvd1NpemUiLCJkZWZhdWx0Q2VudGVyIiwiZGVmYXVsdFpvb20iLCJTaGFyZWRNYXBDb21wb25lbnQiLCJtYXJrZXJzIiwic2V0TWFya2VycyIsImZvb3RwcmludHMiLCJzZXRGb290cHJpbnRzIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImZldGNoTWFwRGF0YSIsInJlc3BvbnNlIiwiZ2V0IiwiZGF0YSIsImZldGNoZWRNYXJrZXJzIiwibWFwIiwibSIsImlkIiwicG9zaXRpb24iLCJwb3B1cENvbnRlbnQiLCJsb2dnZXIiLCJkZWJ1ZyIsImxlbmd0aCIsIndhcm4iLCJmZXRjaGVkRm9vdHByaW50cyIsImZpbHRlciIsImYiLCJ0eXBlIiwiZ2VvbWV0cnkiLCJBcnJheSIsImlzQXJyYXkiLCJjb29yZGluYXRlcyIsIkVycm9yIiwiZXJyIiwibWVzc2FnZSIsImlzRGFya01vZGUiLCJzZXRJc0RhcmtNb2RlIiwiZGl2Iiwic3R5bGUiLCJmbGV4R3JvdyIsIndpZHRoIiwiaGVpZ2h0IiwiY2VudGVyIiwiem9vbSIsInNjcm9sbFdoZWVsWm9vbSIsInpvb21Db250cm9sIiwiYXR0cmlidXRpb24iLCJ1cmwiLCJwIiwiY29sb3IiLCJtYXJrZXIiLCJpY29uIiwiYnIiLCJzbWFsbCIsImZvb3RwcmludCIsInBvc2l0aW9ucyIsImNvb3JkIiwic2NlbmVJZCIsInByb3BlcnRpZXMiLCJzY2VuZV9pZCIsIm5hbWUiLCJwYXRoT3B0aW9ucyIsImJ1dHRvbiIsIm9uQ2xpY2siLCJib3R0b20iLCJyaWdodCIsInpJbmRleCIsInBhZGRpbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXIiLCJib3JkZXJSYWRpdXMiLCJjdXJzb3IiLCJmb250U2l6ZSIsImFyZ3MiLCJjb25zb2xlIiwibG9nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/map/SharedMapComponent.tsx\n");

/***/ })

};
;